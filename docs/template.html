<!DOCTYPE html>
<html lang="en">
<head>
  <title>webstack</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="shortcut icon" type="image/png" href="favicon.ico">
  <style>
    @import url('https://rsms.me/inter/inter.css');
    html { font-family: 'Inter', sans-serif; }
    @supports (font-variation-settings: normal) {
      html { font-family: 'Inter var', sans-serif; }
    }
    body {
      margin: 0;
      padding: 0;
    }
    nav {
      overflow: hidden;
      background-color: #f8f8f8;
      position: fixed;
      padding: 32px;
      top: 0;
      width: 100%;
    }
    main,
    section {
      padding: 96px 32px 6px 32px;
    }
    nav a {
      padding: 0 6px;
    }
    nav a:first-child {
      padding: 0 6px 0 0;
    }
    figure {
      line-height: 1.5em;
      margin-bottom: 32px;
    }
    figcaption {
      font-style: italic;
    }
    p,
    li {
      line-height: 1.5em;
      max-width: 700px;
    }
    pre,
    code {
      font-size: 1.15em;
      line-height: 1.25em;
    }
  </style>
</head>
<body>
  <nav>
    <a href="#overview">overview</a>
    <a href="#heroku">heroku</a>
    <a href="#fly">fly</a>
    <a href="#northflank">northflank</a>
    <a href="#railway">railway</a>
    <a href="#render">render</a>
    <a href="#vercel">vercel</a>
  </nav>

  <main id="overview">
    <h1>webstack</h1>
    <p>
      <i>
        A project to prototype web stacks
        <a
          href="https://github.com/croaky/webstack">source code</a>
      </i>
    </p>

    <figure>
      <pre>
        <code>
REPLACE_DASHBOARD_MAIN</code>
      </pre>
      <figcaption>
        API checks every 10 minutes via <a href="https://www.checklyhq.com/">Checkly</a>
        from N. California, Montreal, Ireland, Stockholm, Sydney
      </figcaption>
    </figure>

    <p>
      I'm interested in comparing <a href="https://heroku.com">Heroku</a> and "New Herokus":
    </p>
    <ul>
      <li><a href="https://fly.io">Fly.io</a></li>
      <li><a href="https://northflank.com/">Northflank</a></li>
      <li><a href="https://railway.app">Railway</a></li>
      <li><a href="https://render.com">Render</a></li>
    </ul>

    <p>
      Each stack serves a healthcheck-style HTTP API endpoint that executes a
      <code>SELECT 1</code> to a SQL database
      and responds with JSON <code>{"status":"ok"}</code>.
      Each stack uses a lightweight router,
      and SQL database driver (no ORM). Example:
    </p>

    <pre>
      <code>
require "connection_pool"
require "pg"
require "sinatra"

pool = ConnectionPool.new(size: 5, timeout: 5) {
  PG.connect(ENV.fetch("DATABASE_URL"))
}

get "/" do
  pool.with { |db| db.exec("SELECT 1") }
  content_type :json
  {status: "ok"}.to_json
end</code>
    </pre>

    <p>
      The traditional (serverful?) stacks use a database connection pool.
      The serverless stacks vary:
    </p>

    <ul>
      <li>
        <a href="https://neon.tech">Neon</a> serverless Postgres
        uses a traditional TCP connection from
        Fly.io and
        <a
          href="https://vercel.com/docs/concepts/functions/serverless-functions">single
          region Vercel serverless functions</a>. The Checkly checks run every 2 minutes in
        order to prevent the Neon database from idling (which happens after 5
        minutes of inactivity).
      </li>
      <li>
        <a href="https://cockroachlabs.cloud/">Cockroach</a> serverless
        Postgres-compatible uses a traditional TCP connection from single region
        Vercel serverless functions the same as Neon.
      </li>
      <li>
        <a href="https://planetscale.com">PlanetScale</a> serverless MySQL
        uses an HTTP connection via their
        <a href="https://planetscale.com/blog/introducing-the-planetscale-serverless-driver-for-javascript">serverless
          driver for JavaScript</a>
        and is executed from
        <a
          href="https://vercel.com/docs/concepts/functions/edge-functions">Vercel's
          global edge functions</a>.
      </li>
    </ul>
  </main>

  <section id="heroku">
    <h2>heroku</h2>
    <p>
      From 2009-2022, my stack most often included Heroku + Postgres:
    </p>
    <ul>
      <li>
        Version code in a GitHub repo
      </li>
      <li>
        Open GitHub pull requests w/
        <a href="https://www.thoughtworks.com/continuous-integration">CI</a>
      </li>
      <li>
        Merge into <code>main</code> branch to auto-deploy to staging
        environment
      </li>
      <li>
        Promote staging manually to production environment in a
        <a href="https://devcenter.heroku.com/articles/pipelines">pipeline</a>
      <li>
        Configure production database with a
        <a
          href="https://devcenter.heroku.com/articles/heroku-postgres-follower-databases">high
          availability follower</a> and continuous backups
      </li>
    </ul>
    <p>
      Cons:
    </p>
    <ul>
      <li>
        Heroku lacks long overdue features such as HTTP/2
      </li>
      <li>
        Some "table stakes" features such as restricting access to
        Postgres from the public internet require a major increase in cost.
      </li>
      <li>
        It's GitHub integration broke April 2022 in
        <a href="https://status.heroku.com/incidents/2413">incident 2413</a> and
        took over a month to restore.
      </li>
    </ul>
  </section>

  <section id="fly">
    <h2>fly</h2>
    <p>
      Pros:
    </p>
    <ul>
      <li>
        Excellent performance and reliability.
      </li>
      <li>
        HTTP/2 support.
      </li>
      <li>
        The CLI is fantastic.
      </li>
      <li>
        HA Postgres databases are available.
      </li>
      <li>
        Multi-region <a
          href="https://fly.io/blog/all-in-on-sqlite-litestream/">Fly +
          SQLite</a> is easily the best performing stack. I'm not sure I have
        any real-world apps I'd design to fit this architecture but it's pretty
        damn cool!
      </li>
      <li>
        A <code>--remote-only</code> option builds on a remote Docker builder
        that they set up in your account. Depending on your builder, you may not
        need Docker installed on your laptop.
      </li>
      <li>
        They support a few Docker or buildpack options including Railway's
        <a href="https://docs.railway.app/deploy/builds">Nixpacks</a>.
        Using the <code>--nixpacks</code> flag, I've seen image sizes
        between 30MB-90MB with deploys finishing in ~40 seconds, which feels
        acceptable.
      </li>
    </ul>
    <p>
      Pros and cons?
    </p>
    <ul>
      <li>
        To automatically deploy my <code>main</code> branch,
        I had to create
        <a
          href="https://github.com/croaky/webstack/blob/main/.github/workflows/fly.yml">a
          GitHub Actions workflow</a>.
        This is not as ergonomic as Render's or Railway's deploys
        but maybe there's a nice security benefit to more intentionally securing
        a secret within the GitHub repo than the OAuth permissions dance?
      </li>
      <li>
        <a
          href="https://fly.io/docs/getting-started/multi-region-databases/">Multi-region
          Postgres read replicas</a>
        initially provided the best read performance for my global tests but
        have been consistently beat by the single region, single Postgres
        version. Curious! Need to dig in more.
      </li>
    </ul>
    <p>
      Cons:
    </p>
    <ul>
      <li>
        <a
          href="https://fly.io/docs/rails/getting-started/migrate-from-heroku/#databases">Fly's
          Postgres databases are not managed</a>.
      </li>
      <li>
        The web UI is not as aesthetic as Railway, Heroku, or Render.
        There is more info in the CLI that could be in the UI.
      </li>
      <li>
        The <code>--nixpacks</code> flag can not currently be used with the
        <code>--remote-only</code> flag. Meaning, to use Nixpacks, you have to
        have Docker installed on your laptop.
      </li>
    </ul>
  </section>

  <section id="northflank">
    <h2>northflank</h2>
    <p>
      Pros:
    </p>
    <ul>
      <li>
        Comprehensive feature set.
      </li>
      <li>
        Excellent UI.
      </li>
      <li>
        Build with Docker, Heroku buildpacks, or Paketo buildpacks.
      </li>
      <li>
        Deploy to US Central or Europe West.
      </li>
      <li>
        Organize infra into projects. Group web service, jobs,
        Postgres, and secrets in the project. Deploy project via
        staging-production pipeline.
      </li>
      <li>
        Managed Postgres.
      </li>
      <li>
        HA Postgres databases.
      </li>
      <li>
        Hourly Postgres backups.
      </li>
      <li>
        Postgres read replicas.
      </li>
      <li>
        Postgres can be networked to be hidden from the internet.
      </li>
      <li>
        HTTP/2 works, TLS terminates at Northflank's routing layer.
      </li>
    </ul>
    <p>
      Cons:
    </p>
    <ul>
      <li>
        Performance doesn't seem as good as Fly or Render.
      </li>
      <li>
        I could get <code>heroku/buildpacks:20</code> working, but not
        <code>heroku/builder:22</code>.
      </li>
      <li>
        Unlike Fly and Render, no built-in DDoS protection.
      </li>
      <li>
        Unlike Fly, not SOC2 certified.
      </li>
      <li>
        Single region deployments.
      </li>
    </ul>
  </section>

  <section id="railway">
    <h2>railway</h2>
    <p>
      Pros:
    </p>
    <ul>
      <li>
        The web UI is absolutely gorgeous.
      </li>
      <li>
        Web services and Postgres are easy to set up and connect to each other.
        The UI provides a great visualization of their relationship.
      </li>
      <li>
        Nice in-browser SQL editor / console.
      </li>
      <li>
        Philosophically aligned with my general mentality of wanting to not
        think in containers.
      </li>
      <li>
        They've been moving to a new packaging system they created called
        <a href="https://docs.railway.app/deploy/builds">Nixpacks</a>.
        They've rapidly added support for languages and builds seem pretty fast.
      </li>
    </ul>
    <p>
      Cons:
    </p>
    <ul>
      <li>
        The only region supported so far is US West.
        <a
            href="https://feedback.railway.app/feature-requests/p/configurable-deployment-region">Other
            regions are planned</a>
      </li>
      <li>
        Postgres databases are exposed to the public internet like Heroku
        Postgres on Heroku's Common Runtime.
        <a
          href="https://feedback.railway.app/feature-requests/p/internal-networking">Private
          networking is planned</a>
      </li>
      <li>
        HA Postgres databases are not available.
      </li>
      <li>
        SSL certs at set with a short expiration, which makes me nervous
        when reviewing
        <a href="https://webstack.checklyhq.com/">my Checkly dashboard</a>.
      </li>
    </ul>
  </section>

  <section id="render">
    <h2>render</h2>
    <p>Pros:</p>
    <ul>
      <li>
        Managed Postgres.
      </li>
      <li>
        <a href="https://render.com/docs/databases">IP access control on
          Postgres databases</a>
      </li>
      <li>
        <a href="https://render.com/docs/ddos-protection">DDoS
          protection</a>
      </li>
      <li>
        HTTP/2 support
      </li>
      <li>
        <a href="https://render.com/docs/deploys#zero-downtime-deploys">Health checks</a>
      </li>
    </ul>
    <p>
      Cons:
    </p>
    <ul>
      <li>
        Render's free tier is not as generous as Fly's or Railway's.
        I've therefore kept fewer Render apps running
        and explored it less than Railway or Fly.
      </li>
      <li>
        The <a href="https://render.com/docs/ruby-version">default Ruby version</a>
        in their environment is 2.6.8.
        The 2.6.x series was superseded by the 2.7.x series on Christmas 2019
        and by the 3.x series on Christmas 2020.
      </li>
      <li>
        HA Postgres databases are not available.
      </li>
    </ul>
  </section>

  <section id="vercel">
    <h2>vercel</h2>
    <p>Pros:</p>
    <ul>
      <li>Innovating on cloud and application architecture.</li>
      <li>Excellent GitHub pull request integration, preview deploys.</li>
      <li>Fast builds</li>
      <li>Great UI</li>
      <li>Vercel serverless functions with Cockroach has surprisngly low latency</li>
      <li>
        With new PlanetScale driver, possible to connect to serverless SQL
        database over HTTP from Vercel's global edge network functions.
      </li>
    </ul>
    <p>Cons:</p>
    <ul>
      <li>
        Connecting to a relational database, even modern cloud SQL databases
        like Cockroach, Neon, and PlanetScale, from serverless functions is a
        work in progress. <a href="https://fauna.com">Fauna</a> seems like it
        was the first to figure out you need to offer an HTTP API to your
        database in a serverless architecture and now some editions of AWS
        Aurora offer an HTTP API.
        <a
          href="https://planetscale.com/blog/introducing-the-planetscale-serverless-driver-for-javascript">PlanetScale
          is rolling out a beta JavaScript driver</a> that connects over HTTP
        to an awesome-sounding global router that then "backhauls" over
        long-held connection pools within their network.
      </li>
      <li>
        I would prefer to use "real Postgres" than Cockroach. My day job app
        uses Postgres functions and triggers, which are unsupported in
        Cockroach.
      </li>
      <li>
         PlanetScale is lovely, but I would prefer to use Postgres than MySQL.
         PlanetScale's HTTP API and global routing, like Fauna before it,
         feel like the natural next necessary step in this architecture.
         Neon and Cockroach aren't at this step yet.
      </li>
      <li>
        Neon is "real Postgres", but separates compute from storage in order
        to support serverless features like "scale to zero". It's looking great
        so far but is a beta product, unready for production workloads.
      </li>
      <li>
        I would prefer to use Go, not JavaScript, in my server-side (whether
        serverful, or serverless) code. The moment I added the `vercel` package
        to the monorepo, I started getting security vulnerability alerts in
        GitHub. It feels messy and unsafe working on top of Node.
        PlanetScale only offers a JavaScript driver as of early October 2022.
        The Vercel edge runtime is built on the V8 JavaScript and WebAssembly
        engine so theoretically, some day you could write Go functions that
        compile to WebAssembly on Vercel's edge network, but that feels a long
        way off.
      </li>
    </ul>
  </section>
</body>
</html>
